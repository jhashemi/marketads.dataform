config {
  type: "test",
  tags: ["test", "performance", "optimization"],
  description: "Performance optimization tests following TDD principles",
  dependencies: ["query_statistics_test"]
}

-- Test Case 1: NTILE vs APPROX_QUANTILES Performance
CREATE OR REPLACE TEMPORARY TABLE test_sales AS
WITH numbers AS (
  SELECT ROW_NUMBER() OVER() as n 
  FROM UNNEST(GENERATE_ARRAY(1, 1000000))
)
SELECT 
  n as id,
  ROUND(RAND() * 10000, 2) as sales_amount,
  DATE_SUB(CURRENT_DATE(), INTERVAL CAST(RAND() * 365 AS INT64) DAY) as sale_date
FROM numbers;

-- Red Light Test: Traditional NTILE approach (should be slower)
CREATE OR REPLACE TEMPORARY TABLE ntile_results AS
SELECT
  id,
  sales_amount,
  NTILE(100) OVER (ORDER BY sales_amount DESC) as sales_percentile,
  TIMESTAMP_DIFF(
    CURRENT_TIMESTAMP(),
    (SELECT MAX(CURRENT_TIMESTAMP()) FROM test_sales),
    MILLISECOND
  ) as execution_time_ms
FROM test_sales;

-- Green Light Test: Optimized APPROX_QUANTILES approach
CREATE OR REPLACE TEMPORARY TABLE quantile_results AS
WITH QuantInfo AS (
  SELECT
    o, qval
  FROM UNNEST((
    SELECT APPROX_QUANTILES(sales_amount, 100)
    FROM test_sales
  )) AS qval
  WITH OFFSET o
  WHERE o > 0
)
SELECT
  id,
  sales_amount,
  (SELECT (101 - MIN(o)) FROM QuantInfo WHERE sales_amount <= qval) as sales_percentile,
  TIMESTAMP_DIFF(
    CURRENT_TIMESTAMP(),
    (SELECT MAX(CURRENT_TIMESTAMP()) FROM test_sales),
    MILLISECOND
  ) as execution_time_ms
FROM test_sales;

-- Test Case 2: COUNT(DISTINCT) vs APPROX_COUNT_DISTINCT Performance
CREATE OR REPLACE TEMPORARY TABLE test_transactions AS
SELECT 
  id,
  CONCAT('CUST_', CAST(1 + MOD(id, 50000) AS STRING)) as customer_id,
  CONCAT('PROD_', CAST(1 + MOD(id, 1000) AS STRING)) as product_id,
  sales_amount
FROM test_sales;

-- Red Light Test: Traditional COUNT(DISTINCT)
CREATE OR REPLACE TEMPORARY TABLE exact_counts AS
SELECT
  DATE_TRUNC(sale_date, MONTH) as sale_month,
  COUNT(DISTINCT customer_id) as exact_customer_count,
  COUNT(DISTINCT product_id) as exact_product_count,
  TIMESTAMP_DIFF(
    CURRENT_TIMESTAMP(),
    (SELECT MAX(CURRENT_TIMESTAMP()) FROM test_transactions),
    MILLISECOND
  ) as execution_time_ms
FROM test_transactions t
JOIN test_sales s ON t.id = s.id
GROUP BY sale_month;

-- Green Light Test: Optimized APPROX_COUNT_DISTINCT
CREATE OR REPLACE TEMPORARY TABLE approx_counts AS
SELECT
  DATE_TRUNC(sale_date, MONTH) as sale_month,
  APPROX_COUNT_DISTINCT(customer_id) as approx_customer_count,
  APPROX_COUNT_DISTINCT(product_id) as approx_product_count,
  TIMESTAMP_DIFF(
    CURRENT_TIMESTAMP(),
    (SELECT MAX(CURRENT_TIMESTAMP()) FROM test_transactions),
    MILLISECOND
  ) as execution_time_ms
FROM test_transactions t
JOIN test_sales s ON t.id = s.id
GROUP BY sale_month;

-- Test Case 3: JOIN Optimization with INT64 vs STRING
CREATE OR REPLACE TEMPORARY TABLE string_keys AS
SELECT 
  CAST(id AS STRING) as string_id,
  customer_id,
  product_id
FROM test_transactions;

-- Red Light Test: STRING JOIN
CREATE OR REPLACE TEMPORARY TABLE string_join_results AS
SELECT
  t.string_id,
  t.customer_id,
  s.sales_amount,
  TIMESTAMP_DIFF(
    CURRENT_TIMESTAMP(),
    (SELECT MAX(CURRENT_TIMESTAMP()) FROM string_keys),
    MILLISECOND
  ) as execution_time_ms
FROM string_keys t
JOIN (SELECT CAST(id AS STRING) as string_id, sales_amount FROM test_sales) s
ON t.string_id = s.string_id;

-- Green Light Test: INT64 JOIN
CREATE OR REPLACE TEMPORARY TABLE int64_join_results AS
SELECT
  t.id,
  t.customer_id,
  s.sales_amount,
  TIMESTAMP_DIFF(
    CURRENT_TIMESTAMP(),
    (SELECT MAX(CURRENT_TIMESTAMP()) FROM test_transactions),
    MILLISECOND
  ) as execution_time_ms
FROM test_transactions t
JOIN test_sales s ON t.id = s.id;

-- Test Case 4: HyperLogLog++ vs COUNT(DISTINCT) for High Cardinality
CREATE OR REPLACE TEMPORARY TABLE test_high_cardinality AS
SELECT 
  id,
  CONCAT(
    'USER_',
    CAST(1 + CAST(FLOOR(RAND() * 10000000) AS INT64) AS STRING)
  ) as user_id,
  CONCAT(
    'SESSION_',
    CAST(1 + CAST(FLOOR(RAND() * 1000000) AS INT64) AS STRING)
  ) as session_id
FROM test_sales;

-- Red Light Test: Traditional COUNT(DISTINCT)
CREATE OR REPLACE TEMPORARY TABLE exact_hll_counts AS
SELECT
  DATE_TRUNC(sale_date, DAY) as event_date,
  COUNT(DISTINCT user_id) as exact_users,
  COUNT(DISTINCT session_id) as exact_sessions,
  TIMESTAMP_DIFF(
    CURRENT_TIMESTAMP(),
    (SELECT MAX(CURRENT_TIMESTAMP()) FROM test_high_cardinality),
    MILLISECOND
  ) as execution_time_ms
FROM test_high_cardinality t
JOIN test_sales s ON t.id = s.id
GROUP BY event_date;

-- Green Light Test: HLL++ Optimization
CREATE OR REPLACE TEMPORARY TABLE hll_counts AS
SELECT
  DATE_TRUNC(sale_date, DAY) as event_date,
  HLL_COUNT.INIT(user_id) as hll_users,
  HLL_COUNT.INIT(session_id) as hll_sessions,
  TIMESTAMP_DIFF(
    CURRENT_TIMESTAMP(),
    (SELECT MAX(CURRENT_TIMESTAMP()) FROM test_high_cardinality),
    MILLISECOND
  ) as execution_time_ms
FROM test_high_cardinality t
JOIN test_sales s ON t.id = s.id
GROUP BY event_date;

-- Test Case 5: Window Function Optimization
CREATE OR REPLACE TEMPORARY TABLE test_window_data AS
SELECT 
  id,
  sales_amount,
  CONCAT('REGION_', CAST(1 + MOD(id, 10) AS STRING)) as region,
  sale_date
FROM test_sales;

-- Red Light Test: Traditional Window Functions
CREATE OR REPLACE TEMPORARY TABLE traditional_window_results AS
SELECT
  id,
  region,
  sales_amount,
  AVG(sales_amount) OVER (
    PARTITION BY region 
    ORDER BY sale_date 
    ROWS BETWEEN 30 PRECEDING AND CURRENT ROW
  ) as moving_avg,
  RANK() OVER (
    PARTITION BY region 
    ORDER BY sales_amount DESC
  ) as sales_rank,
  TIMESTAMP_DIFF(
    CURRENT_TIMESTAMP(),
    (SELECT MAX(CURRENT_TIMESTAMP()) FROM test_window_data),
    MILLISECOND
  ) as execution_time_ms
FROM test_window_data;

-- Green Light Test: Optimized Window Functions with Pre-aggregation
CREATE OR REPLACE TEMPORARY TABLE optimized_window_results AS
WITH pre_aggregated AS (
  SELECT
    region,
    sale_date,
    AVG(sales_amount) as daily_avg,
    MAX(sales_amount) as daily_max
  FROM test_window_data
  GROUP BY region, sale_date
)
SELECT
  w.id,
  w.region,
  w.sales_amount,
  AVG(p.daily_avg) OVER (
    PARTITION BY w.region 
    ORDER BY w.sale_date 
    ROWS BETWEEN 30 PRECEDING AND CURRENT ROW
  ) as moving_avg,
  RANK() OVER (
    PARTITION BY w.region 
    ORDER BY w.sales_amount DESC
  ) as sales_rank,
  TIMESTAMP_DIFF(
    CURRENT_TIMESTAMP(),
    (SELECT MAX(CURRENT_TIMESTAMP()) FROM test_window_data),
    MILLISECOND
  ) as execution_time_ms
FROM test_window_data w
LEFT JOIN pre_aggregated p 
  ON w.region = p.region 
  AND w.sale_date = p.sale_date;

-- Test Case 6: Partitioned Aggregation Optimization
CREATE OR REPLACE TEMPORARY TABLE test_partitioned_data AS
SELECT 
  *,
  DATETIME(sale_date) as sale_datetime,
  CONCAT('CATEGORY_', CAST(1 + MOD(id, 100) AS STRING)) as category
FROM test_window_data;

-- Red Light Test: Traditional Aggregation
CREATE OR REPLACE TEMPORARY TABLE traditional_agg_results AS
SELECT
  sale_date,
  region,
  category,
  COUNT(*) as transaction_count,
  SUM(sales_amount) as total_sales,
  AVG(sales_amount) as avg_sale,
  TIMESTAMP_DIFF(
    CURRENT_TIMESTAMP(),
    (SELECT MAX(CURRENT_TIMESTAMP()) FROM test_partitioned_data),
    MILLISECOND
  ) as execution_time_ms
FROM test_partitioned_data
GROUP BY sale_date, region, category;

-- Green Light Test: Optimized Partitioned Aggregation
CREATE OR REPLACE TEMPORARY TABLE optimized_agg_results AS
WITH hourly_aggs AS (
  SELECT
    DATE(sale_datetime) as sale_date,
    region,
    category,
    COUNT(*) as transaction_count,
    SUM(sales_amount) as total_sales
  FROM test_partitioned_data
  GROUP BY DATE(sale_datetime), region, category
)
SELECT
  sale_date,
  region,
  category,
  SUM(transaction_count) as transaction_count,
  SUM(total_sales) as total_sales,
  SUM(total_sales) / SUM(transaction_count) as avg_sale,
  TIMESTAMP_DIFF(
    CURRENT_TIMESTAMP(),
    (SELECT MAX(CURRENT_TIMESTAMP()) FROM test_partitioned_data),
    MILLISECOND
  ) as execution_time_ms
FROM hourly_aggs
GROUP BY sale_date, region, category;

-- Extended Validation
WITH performance_metrics AS (
  SELECT
    'NTILE vs APPROX_QUANTILES' as test_case,
    (SELECT AVG(execution_time_ms) FROM ntile_results) as baseline_time,
    (SELECT AVG(execution_time_ms) FROM quantile_results) as optimized_time
  UNION ALL
  SELECT
    'COUNT(DISTINCT) vs APPROX_COUNT_DISTINCT',
    (SELECT AVG(execution_time_ms) FROM exact_counts),
    (SELECT AVG(execution_time_ms) FROM approx_counts)
  UNION ALL
  SELECT
    'STRING vs INT64 JOIN',
    (SELECT AVG(execution_time_ms) FROM string_join_results),
    (SELECT AVG(execution_time_ms) FROM int64_join_results)
  UNION ALL
  SELECT
    'HLL++ vs COUNT(DISTINCT)',
    (SELECT AVG(execution_time_ms) FROM exact_hll_counts),
    (SELECT AVG(execution_time_ms) FROM hll_counts)
  UNION ALL
  SELECT
    'Window Functions',
    (SELECT AVG(execution_time_ms) FROM traditional_window_results),
    (SELECT AVG(execution_time_ms) FROM optimized_window_results)
  UNION ALL
  SELECT
    'Partitioned Aggregation',
    (SELECT AVG(execution_time_ms) FROM traditional_agg_results),
    (SELECT AVG(execution_time_ms) FROM optimized_agg_results)
),
accuracy_metrics AS (
  SELECT
    'APPROX_COUNT_DISTINCT Accuracy' as metric,
    ABS(
      (SELECT SUM(exact_customer_count) FROM exact_counts) - 
      (SELECT SUM(approx_customer_count) FROM approx_counts)
    ) / (SELECT SUM(exact_customer_count) FROM exact_counts) as error_rate
  UNION ALL
  SELECT
    'HLL++ Accuracy' as metric,
    ABS(
      (SELECT SUM(exact_users) FROM exact_hll_counts) - 
      (SELECT SUM(HLL_COUNT.EXTRACT(hll_users)) FROM hll_counts)
    ) / (SELECT SUM(exact_users) FROM exact_hll_counts) as error_rate
  UNION ALL
  SELECT
    'Window Function Accuracy',
    ABS(
      (SELECT AVG(moving_avg) FROM traditional_window_results) -
      (SELECT AVG(moving_avg) FROM optimized_window_results)
    ) / (SELECT AVG(moving_avg) FROM traditional_window_results) as error_rate
  UNION ALL
  SELECT
    'Aggregation Accuracy',
    ABS(
      (SELECT AVG(avg_sale) FROM traditional_agg_results) -
      (SELECT AVG(avg_sale) FROM optimized_agg_results)
    ) / (SELECT AVG(avg_sale) FROM traditional_agg_results) as error_rate
)
SELECT
  CASE
    WHEN NOT EXISTS (
      SELECT 1 FROM performance_metrics 
      WHERE optimized_time >= baseline_time
    )
    AND NOT EXISTS (
      SELECT 1 FROM accuracy_metrics
      WHERE error_rate > 0.02
    )
    THEN 'PASS: All optimizations show improvement and maintain accuracy'
    ELSE 'FAIL: Some optimizations did not meet performance or accuracy criteria'
  END as test_result,
  (
    SELECT ARRAY_AGG(STRUCT(
      test_case,
      baseline_time,
      optimized_time,
      ROUND((baseline_time - optimized_time) / baseline_time * 100, 2) as improvement_percent
    ))
    FROM performance_metrics
  ) as performance_summary,
  (
    SELECT ARRAY_AGG(STRUCT(
      metric,
      error_rate
    ))
    FROM accuracy_metrics
  ) as accuracy_summary; 