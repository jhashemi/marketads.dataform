config {
  type: "table",
  name: "customer_matches",
  description: "Matched customer records with confidence scores",
  columns: {
    source_id: "Source record unique identifier",
    target_id: "Target record unique identifier",
    match_confidence: "Confidence score for the match (0-1)",
    match_tier: "Match quality tier (HIGH, MEDIUM, LOW)",
    first_name_score: "First name match score component",
    last_name_score: "Last name match score component",
    email_score: "Email match score component",
    address_score: "Address match score component",
    matched_date: "Date when the match was performed"
  },
  tags: ["matching", "customer_data"],
  assertions: {
    nonNull: ["source_id", "target_id", "match_confidence"],
    rowConditions: [
      "match_confidence >= 0 AND match_confidence <= 1",
      "match_tier IN ('HIGH', 'MEDIUM', 'LOW')"
    ]
  }
}

-- Simple example of a matching query
-- In a real scenario, this would use JS functions from includes
WITH source_data AS (
  SELECT * FROM ${ref("sources.customer_data")}
),
target_data AS (
  SELECT * FROM ${ref("sources.customer_master")}
)

SELECT 
  s.customer_id AS source_id,
  t.id AS target_id,
  -- Calculate match confidence from multiple components
  (
    CASE WHEN s.email_address = t.email THEN 0.6 ELSE 0 END +
    CASE WHEN SOUNDEX(s.first_name) = SOUNDEX(t.first_name) THEN 0.2 ELSE 0 END +
    CASE WHEN SOUNDEX(s.last_name) = SOUNDEX(t.last_name) THEN 0.2 ELSE 0 END
  ) AS match_confidence,
  
  -- Determine match tier based on confidence
  CASE
    WHEN (
      CASE WHEN s.email_address = t.email THEN 0.6 ELSE 0 END +
      CASE WHEN SOUNDEX(s.first_name) = SOUNDEX(t.first_name) THEN 0.2 ELSE 0 END +
      CASE WHEN SOUNDEX(s.last_name) = SOUNDEX(t.last_name) THEN 0.2 ELSE 0 END
    ) >= 0.9 THEN 'HIGH'
    WHEN (
      CASE WHEN s.email_address = t.email THEN 0.6 ELSE 0 END +
      CASE WHEN SOUNDEX(s.first_name) = SOUNDEX(t.first_name) THEN 0.2 ELSE 0 END +
      CASE WHEN SOUNDEX(s.last_name) = SOUNDEX(t.last_name) THEN 0.2 ELSE 0 END
    ) >= 0.75 THEN 'MEDIUM'
    ELSE 'LOW'
  END AS match_tier,
  
  -- Individual score components
  CASE WHEN SOUNDEX(s.first_name) = SOUNDEX(t.first_name) THEN 1.0 
       ELSE REGEXP_REPLACE(CAST(LEVENSHTEIN(s.first_name, t.first_name) / GREATEST(LENGTH(s.first_name), LENGTH(t.first_name)) AS STRING), r"0\.", ".") END AS first_name_score,
  CASE WHEN SOUNDEX(s.last_name) = SOUNDEX(t.last_name) THEN 1.0 
       ELSE REGEXP_REPLACE(CAST(LEVENSHTEIN(s.last_name, t.last_name) / GREATEST(LENGTH(s.last_name), LENGTH(t.last_name)) AS STRING), r"0\.", ".") END AS last_name_score,
  CASE WHEN s.email_address = t.email THEN 1.0 ELSE 0.0 END AS email_score,
  0 AS address_score, -- Placeholder for address matching
  CURRENT_DATE() AS matched_date

FROM source_data s
JOIN target_data t
  -- Join on blocking keys to reduce comparison space
  ON (
    -- Simple blocking based on first letter of name + first 3 of last name
    CONCAT(SUBSTR(s.first_name, 1, 1), SUBSTR(s.last_name, 1, 3)) = 
    CONCAT(SUBSTR(t.first_name, 1, 1), SUBSTR(t.last_name, 1, 3))
    -- Add additional blocking conditions with OR
  )
WHERE 
  -- Only keep records above minimum confidence threshold
  (
    CASE WHEN s.email_address = t.email THEN 0.6 ELSE 0 END +
    CASE WHEN SOUNDEX(s.first_name) = SOUNDEX(t.first_name) THEN 0.2 ELSE 0 END +
    CASE WHEN SOUNDEX(s.last_name) = SOUNDEX(t.last_name) THEN 0.2 ELSE 0 END
  ) >= 0.5
ORDER BY match_confidence DESC
